\chapter{Fundamentos Teóricos}\label{cap-fundamentos}

\section{Detectores por Produto Interno com Minimização do Erro Quadrático Médio (IPD)} \label{sec_IPD}
               
O projeto do classificador utilizando detector por produto interno pode ser feito da seguinte forma: suponhamos uma variável aleatória, ou seja, uma variável cujo os seus resultados sejam imprevisíveis, $X_{dx1}$. Suas realizações podem ser classificadas nas classes {${A_1},\,{A_2},\,...,\,{A_n}$} ou na classe B, sendo que a classe ${A_i}$ representa os padrões que desejamos encontrar e B representa os demais padrões que não seja de interesse. As probabilidades de encontrarmos essas classes são dadas por:
                 
\begin{equation}\label{eq_prob}
\begin{array}{l}
p({A_i}) = p(\mathcal{X} \in {A_i}) = {p_i}\\
p(B) = p(\mathcal{X} \in B)
\end{array}
\end{equation}

O classificador \textbf{h} é projetado de tal forma que o produto interno dele com uma entrada $\mathcal{X}$ seja dado por:
                
\begin{equation}\label{eq_probabilidades}
<\mathcal{X}, h_{A_{i}}>=h^{t}_{A_{i}}\mathcal{X}=C 
\end{equation}
                
Onde $\mathcal{C}$=1 caso $\mathcal{X} \in A_i$  e $\mathcal{C}=0$ para $\mathcal{X} \in A_{i}$.
                
Se tomarmos o problema dos mínimos quadrados que tenta minimizar a soma dos quadrados das diferenças entre o valor estimado e os dados observados, a equação \eqref{eq_probabilidades} procura encontrar o melhor classificador possível. Sendo assim, podemos definir o erro como:

\begin{equation}
\varepsilon=h^{t}_{Ai}\mathcal{X}-\mathcal{C}
\end{equation}
        
Assim, considerando-se definição de erro quadrático temos:
                
\begin{equation}
||\varepsilon||^{2}=(h^{t}_{Ai}\mathcal{X}-\mathcal{C})(h^{t}_{Ai} \mathcal{X}-\mathcal{C})^{t}\label{eq_erroQuad}
\end{equation}
                
Assumindo que \textit{$h_{A_{i}}$}, $\mathcal{X}$ e $\mathcal{C}$ como valores reais e desenvolvendo  a equação \eqref{eq_erroQuad} chegaremos ao valor esperado do erro quadrático como sendo:
                

\begin{equation} \label{eq_erroQuadratico}
E[||\varepsilon|{|^2}] = h_{Ai}^tE[\mathcal{X}{\mathcal{X}^t}]{h_{Ai}} - 2h_{Ai}^tE[\mathcal{XC}] + E[{\mathcal{C}^2}]
\end{equation}
                
Afim de minimizarmos o erro quadrático da equação \eqref{eq_erroQuadratico} igualamos a zero (0) o seu gradiente em relação a \textit{$h_{A_{i}}$}. Dessa forma, obtemos a seguinte expressão:
                
\[
\begin{array}{l}
\frac{\partial E[||\varepsilon |{|^2}]}{{\partial {h_{Ai}}}} = \frac{\partial }{{\partial {h_{Ai}}}}\{ h_{Ai}^tE[\mathcal{X}{\mathcal{X}^t}]{h_{Ai}} - 2h_{Ai}^tE[\mathcal{XC}] + E[{\mathcal{C}^2}]\} \\
0 = \{ E[\mathcal{X}{\mathcal{X}^t}] + E{[\mathcal{X}{\mathcal{X}^t}]^t}\} {h_{Ai}} - 2E[\mathcal{XC}]\\
2E[\mathcal{X}{\mathcal{X}^t}]{h_{Ai}} - 2E[\mathcal{XC}] = 0
\end{array}
\]
                
Logo,

\begin{equation}\label{vetorH}
\begin{array}{l}
E[\mathcal{X}{\mathcal{X}^t}]{h_{Ai}} = E[\mathcal{XC}]\\
{h_{Ai}} = {\{ E[\mathcal{X}{\mathcal{X}^t}]\} ^{ - 1}}E[\mathcal{XC}]
\end{array}
\end{equation}
                
Os termos $E[\mathcal{X}{\mathcal{X}^t}]$ e $E[\mathcal{XC}]$ até então são desconhecidos. Podemos desenvolver o termo $E[\mathcal{X}{\mathcal{X}^t}]$ da seguinte forma:

\begin{equation}\label{eqSeiSete}
E[\mathcal{X}{\mathcal{X}^t}] = E[\mathcal{X}{\mathcal{X}^t}|B]p(B) + \sum\limits_{j = 1}^n E [\mathcal{X}{\mathcal{X}^t}|{A_j}]p({A_j})
\end{equation}

Lembrando o iníco da seção onde definimos as classes ${A_1},\,{A_2},\,...,\,{A_n}$ e a classe B onde podemos encontrar ${B_1},\,{B_2},\,...,\,{B_n}$, podemos encontrar as médias da equação \eqref{eqSeiSete} da seguinte forma:

\begin{equation}
\begin{array}{l}
E[\mathcal{X}{\mathcal{X}^t}] = E[\mathcal{X}{\mathcal{X}^t}|B]p(B) + \sum\limits_{j = 1}^n E [\mathcal{X}{\mathcal{X}^t}|{A_j}]p({A_j})\\
 = p(B)\frac{1}{r}\sum\limits_{j = 1}^r {{B_j}B_j^t + } \sum\limits_{j = 1}^n {p({A_j})\frac{1}{{{L_j}}}} \sum\limits_{k = 1}^{{L_j}} {{A_{jk}}A_{jk}^t} \\
 = p(B)\frac{1}{r}\sum\limits_{j = 1}^r {{B_j}B_j^t + } \sum\limits_{j = 1}^n {{p_j}\frac{1}{{{L_j}}}} \sum\limits_{k = 1}^{{L_j}} {{A_{jk}}A_{jk}^t} 
\end{array}
\end{equation}

Conforme verificamos na equação \eqref{eq_probabilidades}, obteremos a saída igual a 1 para o caso da variável aleatória X for classificada na classe $A_i$ e 0 caso contrário. Seguindo o raciocínio desenvolvido para a classe A temos as classes representadas através do complemento de $A_i$, dado por $A_i^C$:

\begin{equation}
\begin{array}{l}
E[\mathcal{XC}] = E[\mathcal{XC}|{A_i}]p({A_i}) + E[\mathcal{XC}|A_i^C](1 - p({A_i}))\\
 = E[\mathcal{X}|{A_i}]p({A_i}) + 0(1 - p({A_i}))\\
 = {p_i}\frac{1}{{{L_1}}}\sum\limits_{k = 1}^{{L_1}} {{A_{ik}}} 
\end{array}
\end{equation} 

Assim, a equação \eqref{vetorH}, pode ser reescrita da forma:

\begin{equation}
{h_{Ai}} = {\{ p(B)\frac{1}{r}\sum\limits_{j = 1}^r {{B_j}B_j^t}  + \sum\limits_{j = 1}^n {{p_j}\frac{1}{{{L_j}}}\sum\limits_{k = 1}^{{L_j}} {{A_{jk}}A_{jk}^t} } \} ^{ - 1}}\{ {p_i}\frac{1}{{{L_i}}}\sum\limits_{k = 1}^{{L_i}} {{A_{ik}}} \}
\end{equation}

Considerando-se a matriz de autocorrelação de $B$ igual a $R_B$ e a matriz $A_i$ igual a $R_{Ai}$, e a média $A_i$ igual a $\mu_{Ai}$, podemos expressar os resultados em função das variáveis aleatórias, assim, temos:

\begin{equation}\label{vetorH_final}
{h_{Ai}} = {\{ p(B){R_B} + \sum\limits_{j = 1}^n {{p_j}{R_{Aj}}} \} ^{ - 1}}\{\sum\limits_{i = 1}^m {{p_i}{\mu _{Ai}}}\}
\end{equation}

A condição de existência do classificador projetado é que o primeiro termo da equação \eqref{vetorH_final} seja uma matriz inversível e a dimensão dos vetores de entrada deve ser menor que a soma dos números de elementos de todas as classes $A_j$ e B, ou seja $d \le \,r\, + \,\sum\limits_{j = 1}^n {{L_j}}$.
              
\section{Detector por Produto Interno utilizando Análise de Componentes Principais (IPD-B-PCA)}

Com o intuito de aumentar a robustez do detector por produto interno (IPD) a pequenas rotações, utilizou-se a técnica de análise de componentes principais (do inglês, \textit{Principal Component Analysis} - PCA) \cite{waldir}. A principal motivação para a aplicação dessa técnica reside no fato de que os padrões analisados não são distribuídos de forma aleatória, e mesmo essas estando distribuídas em um espaço de alta dimensão, assim, podem ser representadas por um subespaço de menor dimensão. O conjunto dessas componentes principais são denominadas \textit{eigenfaces} (o termo \textit{eigenfaces} deve-se ao fato da representação das faces através dos autovetores do conjunto de faces).

\subsection*{\textit{Eigenpoints}}

O termo \textit{eigenpoints} refere-se a um método que faz uso do padrão comum existente nas faces para representá-los em um subespaço de dimensão inferior ou igual ao original, assim, podemos utilizar \textit{eigenpoints} para encontrarmos os pontos fiduciais\footnote{características salientes comum as faces, como canto da boca, olho, nariz, etc.} (do inglês, \textit{fiducial point}) de um conjunto de faces, por exemplo. \textit{Eigenpoints} constitui-se um caso específico de \textit{eigenfaces}, porém, ao invés de utilizarmos faces utilizamos somente blocos da região de interesse (ponto fiducial desejado), conforme pode ser visto na Figura \ref{fig:eigenfacesEx} e \ref{fig:eigenpointsEx}. Ao combinarmos essa técnica ao classificador IPD temos como resultado um sistema mais robusto a pequenas rotações \cite{waldir}.

Matematicamente podemos obter os \textit{eigenpoints} como sendo \textit{M} realizações de uma variável aleatória $\mathcal{X}_{Nx1}$ iguais a $x_{\textit{i}}$. Cada coluna $x_{\textit{i}}$ contém os \textit{pixels} de blocos centrados em pontos fiduciais ${\gamma_\textit{i}}$, onde \textit{i} = \{1,..., M\}. Dessa forma, \textbf{X} é uma matriz formada por \textit{M} vetores (sendo \textit{M} > \textit{N}) da seguinte forma:

\begin{equation}
\textbf{X} = [{x_1} - {\mu _\mathcal{X}},\,...,\,{x_M} - {\mu _\mathcal{X}}]
\end{equation}

Onde $\mu _\mathcal{X}$ é:

\begin{equation}
{\mu _\mathcal{X}} = \frac{1}{M}\sum\limits_{i = 1}^M {{x_\textit{i}}}
\end{equation}

Seja \textbf{$\mathbf{\Sigma}_\mathcal{X}$} a matriz de covariância de $\mathcal{X}$, dada por:

\begin{equation}
\mathbf{\Sigma}_\mathcal{X}  =  \frac{1}{{M - 1}}\textbf{X}{\textbf{X}^T}
\end{equation}

Dessa forma, a base que contém as \textit{N} componentes principais descorrelacionadas (\textit{eingenpoints}) é encontrada através da diagonalização da matriz $\mathbf{\Sigma}_\mathcal{X}$, assim:

\begin{equation}
\mathbf{\Lambda} = \mathbf{\Phi}^{*t} \mathbf{\Sigma}_{\mathcal{X}} \mathbf{\Phi}.
\end{equation}

onde $\Phi  = [{\phi _1},\,{\phi _2},\,...,\,{\phi _N}]$ é a matriz de autovetores de $\mathbf{\Sigma}_\mathcal{X}$, o sobrescrito \textit{T} indica o transposto da matriz de covariância e $\Lambda$ é a matriz diagonal contendo os valores de $\sum\nolimits_\mathcal{X}$, onde cada autovalor ${\lambda _\textit{i}}$ tem uma variância maior ou igual ao seu sucessor, ou seja, ${\lambda _1} \ge {\lambda _2} \ge ... \ge {\lambda _N}$. Dessa forma, é possível selecionar os componentes de maior energia através dos autovalores ${\lambda _i}$. Assim, podemos dizer que o método PCA e os \textit{eingenfaces} são as \textit{k} componentes principais de $\Phi_{\textit{i}}$.

\begin{figure}[h]
\subfigure[Exemplos de \textit{eigenfaces}]{
\includegraphics[width=7.15cm,height=2cm]{figuras/eigenfacesEx.png}
\label{fig:eigenfacesEx}
}
\subfigure[Exemplos de \textit{eigenpoints}]{
\includegraphics[width=7.15cm,height=2cm]{figuras/eigenPointsEx.png}
\label{fig:eigenpointsEx}}
\caption{Exemplos de \textit{eigenfaces}  à direita e a esquerda temos \textit{eigenpoints} extraídos a partir de blocos centrados a partir do olho direito das imagens das faces.}
\end{figure}

\subsection*{Formulação do IPD-B-PCA}

O método utilizado consiste em aumentar a robustez dos filtros discriminativos através das componentes principais de maior energia, ou seja, cujos autovalores associados são maiores \cite{waldir}. Matematicamente podemos obter esses filtros da seguinte maneira: suponhamos uma  variável aleatória que pode ser classificadas nas classes \{${\mathcal{A}_1},\,{\mathcal{A}_2},\,...,\,{\mathcal{A}_N}$\} onde: 

\begin{itemize}
\item A classe ${\mathcal{A}_1}$ será composta pela componente que desejamos detectar (${\mathcal{A}_1=\{\phi _i\}}$);

\item A classe ${\mathcal{A}_2}$ refere-se a deslocamentos lineares de $\phi _i$. A expressão $\phi _i^{n,m}$ relaciona o deslocamento linear da componente \textit{i} em \textit{n} \textit{pixels} na direção horizontal e \textit{m} na vertical. Considerando-se blocos quadrados de tamanho \textit{L} em que o centro do bloco contém o ponto fiducial de interesse, podemos escrever ${\mathcal{A}_2} = \{ \phi _i^{n,m}$, onde: $- L \le \,m,n\, \le \,L$, com $n,m \ne \,0\}$ .

\item A classe $\mathcal{B}$ será composta pelas demais componentes $\phi _j$, ou seja, as classes \newline\{${\mathcal{A}_3},\,{\mathcal{A}_4},\,...,\,{\mathcal{A}_N}$\}.
\end{itemize}

Para projetarmos o nosso classificador utilizaremos a equação \eqref{vetorH_final}, levando-se em consideração as premissas citadas teremos:

\begin{equation}\label{eq_ipd_pca}
{h_{{\phi _1}}} = {\left\{ {{p_1}{R_{A1}} + {p_2}{R_{A2}} + {p_B}{R_B}} \right\}^{ - 1}}\,{p_1}{R_{A1}}
\end{equation}

A Figura \ref{fig_ipd_pca} ilustra o esquema proposto, onde temos \textit{S} \textit{eigenpoints} ($\Phi  = \,{\phi _1},\,{\phi _2},\,...,\,{\phi _S}$), para cada um será projetado um filtro, de forma que estejam dispostos do maior para o menor valor de variância (autovalores), desse modo, ${\lambda _1} \ge \,{\lambda _2} \ge ,...,\,{\lambda _S}$.

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.9]{figuras/esquema_Matriz.png}
\caption{\textit{S} classificadores para \textit{S} componentes principais.}
\label{fig_ipd_pca}
\end{figure}

Na Figura \ref{fig_schema}, podemos observar um \textit{eigenpoint} que refere-se ao olho direito considerando-se apenas a primeira componente principal. A componente $\phi_1$ foi calculada através de blocos de dimensão $2L+1$ (imagem à esquerda). Afim de obtermos a componente $\phi_2$ através de deslocamentos lineares de meio bloco calculamos $\mathop {{\phi _i}}\limits^ \sim$ para blocos de dimensão $4L+1$ (imagem à direita). Assim, reescrevendo a equação \eqref{eq_ipd_pca} em função dessas ponderações teremos:

\begin{figure}[!htb]
\centering
\includegraphics[scale=0.7]{figuras/Schema.png}
\caption{Desclocamento linear}
\label{fig_schema}
\end{figure}


\begin{equation} \label{eq_IPD-B-PCA_Final}
h{\phi _i} = {\left\{ \begin{array}{l}
{p_1}{\phi _i}{({\phi _i})^{T}} + {p_2}\frac{1}{{{{(2L + 1)}^2} - 1}}\,\sum\limits_{n =  - L\hfill\atop
n \ne 0\hfill}^L {\sum\limits_{m =  - L\hfill\atop
m \ne 0\hfill}^L {{\phi _i}^{(n,m)}({\phi _i}^{(n,m)})^{T} }} +\\
 + p(\mathcal{B})\,\frac{1}{{N - 1}}\,\sum\limits_{j = 1\hfill\atop
j \ne i\hfill}^N {{\phi _j}{{({\phi _j})}^{T}}} 
\end{array} \right\}^{ - 1}}\,{p_1}{\phi _i}
\end{equation}

Finalmente, a equação \eqref{eq_IPD-B-PCA_Final} expressa o detector por produto interno utilizando análise de componentes principais. Salienta-se que na construção dos padrões de interesse da classe $\mathcal{A}_1$ podemos utilizar componentes levemente rotacionados ou deslocados, dessa forma é possível construir detectores mais robustos. A classe ${\mathcal{A}_2}$ é de fundamental importância, uma vez que se considerássemos somente as classes dos padrões de interesse poderíamos discriminar um falso positivo, ou seja, a classe $\mathcal{A}_1$ deslocada. Esse fato, deve-se a linearidade dos filtros, portanto, pequenas alterações na entrada produzem apenas pequenas perturbações na saída. Assim, a adição da classe ${\mathcal{A}_2}$ permite ao classificador rejeitar pequenos deslocamentos lineares de forma mais precisa e com uma maior eficiência.
                      
\section{Computação Paralela}

Com a crescente exigência de um maior poder de processamento computacional e o limite físico imposto a velocidade dos processadores (\textit{clock}) surgiu a ideia de dividir a carga de processamento em vários núcleos (ou \textit{cores}). A ideia central da computação paralela é de que um tarefa geralmente pode ser dividida em partes menores e executadas de forma concorrente, ganhando assim tempo de processamento \cite{culler1999parallel}. Assim temos a chamada de \textit{computação de alto desempenho} - HPC (do inglês, \textit{High Performance Computing}) se propõe a otimizar esse processamento diminuindo o tempo de execução das tarefas em geral.

O paralelismo, no entanto, adicionou novas complexidade ao sistema sequencial, como a distribuição eficiente de processamento pelos vários processadores e a sincronização de tarefas. A diferença entre processamento sequencial e paralelo pode ser visto na Figura \ref{fig:TiposProc}, nela é intuitivo perceber que para uma mesma tarefa o processamento paralelo \ref{fig:P_Paralelo} irá gastar menos tempo na sua execução quando compararmos com o processamento sequencial \ref{fig:P_Sequencial}.

\begin{figure}[h]
\subfigure[Processamento sequencial]{
\includegraphics[width=7.15cm,height=2cm]{figuras/PP_Seq.png}
\label{fig:P_Sequencial}
}
\subfigure[Processamento Paralelo]{
\includegraphics[width=7.15cm,height=2cm]{figuras/PP_P.png}
\label{fig:P_Paralelo}}
\caption{Diferença entre processamento sequencial e processamento paralelo.}
\label{fig:TiposProc}
\end{figure}

Michael Flynn \cite{flynn1996parallel} classifica os sistemas paralelos com base no fluxo de dados e de instruções. Segundo Flynn, a arquitetura computacional poder ser encarada como uma relação entre o fluxo de dados e de instruções, sendo que o fluxo de instruções é executado pelo processador sobre um fluxo de dados aos quais essas instruções estão relacionadas. Com base na unicidade e multiplicidade dos fluxos de dados e das instruções, as arquiteturas de computadores são divididas em 4 classes:

\begin{itemize}
\item \textbf{SISD (\textit{Single Instruction Single Data} - Fluxo único de instruções Fluxo único de dados)}: Consiste na computação predominante há algum tempo, onde as instruções são executadas sequencialmente sobre um conjunto de dados. Também é conhecido como computador serial;

\item \textbf{SIMD (\textit{Single Instruction Multiple Data} - Fluxo único de instruções Fluxo múltiplo de dados)}: Nesse modelo temos vários processadores executando simultaneamente as mesmas instruções em diversos conjuntos de dados sob o controle de uma única unidade de controle mestre.

\item \textbf{MISD (\textit{Multiple Instruction Single Data} - Fluxo múltiplo de instruções Fluxo único de dados)}: Nessa arquitetura temos múltiplos processadores que executam diferentes instruções sobre um único conjunto de dados.

\item \textbf{MIMD (\textit{Multiple Instruction Multiple Data} - Fluxo múltiplo de instruções Fluxo múltiplo de dados)}: Aqui temos múltiplos processadores executando diferentes instruções em diferentes conjuntos de dados independentemente. Essa é a arquitetura mais usada pelos  atuais computadores.

\end{itemize}

\begin{figure}[h]
\subfigure[Arquitetura SISD]{
\includegraphics[scale=0.75]{figuras/Flynn_SISD.png}
\label{fig:Flynn_SISD}
}
\subfigure[Arquitetura SIMD]{
\includegraphics[scale=0.75]{figuras/Flynn_SIMD.png}
\label{fig:Flynn_SIMD}
}
\subfigure[Arquitetura MISD]{
\includegraphics[scale=0.7]{figuras/Flynn_MISD.png}
\label{fig:Flynn_SISD}
}
\subfigure[Arquitetura MIMD]{
\includegraphics[scale=0.7]{figuras/Flynn_MIMD.png}
\label{fig:Flynn_SIMD}
}
\caption{Arquiteturas de Flynn}
\label{fig:TiposProc}

\end{figure}
Onde:
\textbf{FI}: Fluxo de Instruções; \textbf{UC}: Unidade de Controle; \textbf{FD}: Fluxo de dados; \textbf{M}: Memória; \textbf{UP}: Unidade de Processamento.

A arquitetura MIMD também pode ser divida de acordo com o tipo de acesso a memória:

\begin{itemize}

\item \textbf{Memória compartilhada ou \textit{Uniform Memory Access Multiprocessor} - UMA}: Nesse modelo as tarefas compartilham de um mesmo espaço de memória e a comunicação é mais simples, pois utiliza-se de uma área comum na memória (Figura \ref{fig:Mem_Compartilhada}). Todos os processadores podem acessar toda a memória, também são chamados de multiprocessadores, existe apenas um espaço de endereçamento que é usado de forma implícita para a comunicação entre os processadores;

\item \textbf{Memória distribuída ou \textit{Nonuniform Memory Access Multiprocessor} - NUMA}: Nesse padrão cada processador possui o seu próprio endereço na memória (Figura \ref{fig:Mem_Ditribuida}). A interligação entre processadores e memória é feita através de uma rede de interconexão. O acesso aos dados remotos é realizado através de troca de mensagens.

\end{itemize}

\begin{figure}[h]
\subfigure[Memória compartilhada - UMA]{
\includegraphics[scale=0.75]{figuras/Tipos_Memorias_Shared.PNG}
\label{fig:Mem_Compartilhada}
}
\subfigure[Memória distribuída - NUMA]{
\includegraphics[scale=0.8]{figuras/Tipos_Memorias.PNG}
\label{fig:Mem_Ditribuida}}
\caption{Diferença entre processamento sequencial e processamento paralelo.}
\label{fig:Mem_Acesso}
\end{figure}

Podemos destacar dois tipos de paralelismo: implícito e explícito. Diz-se que o paralelismo é implícito quando cabe ao compilador ou ao sistema paralelizar a aplicação. O paralelismo é dito explícito quando cabe ao programador indicar os pontos que serão processados de forma paralela. 

O desempenho de um algoritmo sequencial geralmente é avaliado pelo seu tempo de execução, já o tempo de execução de um algoritmo paralelo depende, além do tamanho de entrada de dados, de fatores como o número de processadores e a arquitetura do computador. Culler \cite{culler1999parallel} afirma que o desempenho de um sistema paralelo é a combinação do algoritmo e a arquitetura na qual ela foi implementada . Algumas métricas são comumente utilizadas, são elas, o tempo de execução, fator de aceleração (ou \textit{speedup}), eficiência e o custo.

\chapter{Fundamentos Específicos}\label{cap-especifico}

\section{Contextualização do Problema} \label{sec_IPD}

